
import streamlit as st
import google.generativeai as genai
from PyPDF2 import PdfReader
import os
from dotenv import load_dotenv
import re
from typing import List, Dict, Any

# Load environment variables
load_dotenv()

# Configure the Gemini API
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

# --- Helper Functions ---

def get_pdf_text(pdf_docs) -> str:
    """Extracts text from a list of PDF documents."""
    text = ""
    for pdf in pdf_docs:
        pdf_reader = PdfReader(pdf)
        for page in pdf_reader.pages:
            text += page.extract_text()
    return text

def get_gemini_response(prompt_parts: List[str], model_name: str = "gemini-2.5-flash") -> str:
    """Gets a response from the Gemini model."""
    try:
        model = genai.GenerativeModel(model_name)
        response = model.generate_content(prompt_parts)
        return response.text
    except Exception as e:
        st.error(f"Error communicating with Gemini: {e}")
        return ""

def parse_quiz_response(quiz_text: str) -> Dict[str, Any]:
    """Parses the quiz text generated by Gemini into a structured format."""
    quiz_data = {"mcqs": [], "true_false": [], "fill_in_the_blank": []}

    # Regular expressions for parsing
    mcq_pattern = re.compile(r'\d+\.\s*(.*?)\n\s*a\)\s*(.*?)\n\s*b\)\s*(.*?)\n\s*c\)\s*(.*?)\n\s*d\)\s*(.*?)\n\s*Answer:\s*([a-d])\)')
    tf_pattern = re.compile(r'\d+\.\s*(.*?)\s*\((True|False)\)\n\s*Answer:\s*(True|False)')
    fib_pattern = re.compile(r'\d+\.\s*(.*?)\n\s*Answer:\s*(.*)')

    # Parse MCQs
    for match in mcq_pattern.finditer(quiz_text):
        quiz_data["mcqs"].append({
            "question": match.group(1).strip(),
            "options": {
                "a": match.group(2).strip(),
                "b": match.group(3).strip(),
                "c": match.group(4).strip(),
                "d": match.group(5).strip(),
            },
            "correct_answer": match.group(6).strip()
        })

    # Parse True/False
    for match in tf_pattern.finditer(quiz_text):
        quiz_data["true_false"].append({
            "question": match.group(1).strip(),
            "correct_answer": match.group(3).strip()
        })

    # Parse Fill-in-the-Blank
    for match in fib_pattern.finditer(quiz_text):
        quiz_data["fill_in_the_blank"].append({
            "question": match.group(1).strip(),
            "correct_answer": match.group(2).strip()
        })

    return quiz_data


# --- Streamlit UI ---

def main():
    st.set_page_config(page_title="Study Assistant", layout="wide", page_icon=":books:")
    st.title("üìö Study Notes Summarizer & Quiz Generator")

    st.sidebar.header("Upload your PDF")
    uploaded_files = st.sidebar.file_uploader(
        "Choose PDF files", accept_multiple_files=True, type=["pdf"]
    )

    if uploaded_files:
        if st.sidebar.button("Summarize"):
            with st.spinner("Extracting text and summarizing..."):
                raw_text = get_pdf_text(uploaded_files)

                if raw_text:
                    st.session_state.raw_text = raw_text

                    # Summarization
                    summary_prompt = "Provide a concise, clean, and meaningful summary of the following text, suitable for a student's study notes:"
                    summary = get_gemini_response([raw_text, summary_prompt])
                    
                    st.subheader("üìù Summary")
                    st.container(border=True).write(summary) # Using a container for display

                else:
                    st.error("üö´ Could not extract text from the PDF. It might be empty, scanned, or protected.")

    if "raw_text" in st.session_state:
        st.divider()
        st.subheader("üß† Quiz Time!")
        if st.button("Create Quiz"):
            with st.spinner("Generating quiz questions..."):
                quiz_prompt = """
                Based on the following text, create a quiz.
                Include:
                - At least 10 Multiple-Choice Questions (MCQs), each with 4 options (a, b, c, d) and indicate the correct answer.
                - At least 5 True/False questions, indicating the correct answer.
                - At least 5 Fill-in-the-Blank questions, indicating the correct answer.

                Format the quiz strictly as follows:

                **Multiple-Choice Questions:**
                1. [Question Text]?
                   a) [Option A]
                   b) [Option B]
                   c) [Option C]
                   d) [Option D]
                   Answer: [a|b|c|d]

                **True/False Questions:**
                1. [Statement Text]. (True/False)
                   Answer: [True|False]

                **Fill-in-the-Blank Questions:**
                1. [Sentence with blank indicated by '_____'].
                   Answer: [Correct word/phrase]
                """
                quiz_raw_text = get_gemini_response([st.session_state.raw_text, quiz_prompt])
                st.session_state.quiz_data = parse_quiz_response(quiz_raw_text)

                st.success("Quiz generated successfully! Scroll down to answer.")
        
        if "quiz_data" in st.session_state:
            quiz_data = st.session_state.quiz_data
            st.subheader("Answer the Quiz Questions")
            
            # --- MCQs ---
            if quiz_data["mcqs"]:
                st.markdown("#### Multiple-Choice Questions")
                user_mcq_answers = {}
                for i, mcq in enumerate(quiz_data["mcqs"]):
                    st.markdown(f"**{i+1}. {mcq['question']}**")
                    options = [f"a) {mcq['options']['a']}",
                               f"b) {mcq['options']['b']}",
                               f"c) {mcq['options']['c']}",
                               f"d) {mcq['options']['d']}"]
                    user_mcq_answers[i] = st.radio("Select your answer:", options, key=f"mcq_{i}")
                
                if st.button("Check MCQ Answers", key="check_mcq"):
                    st.markdown("---")
                    st.markdown("#### MCQ Results")
                    score_mcq = 0
                    for i, mcq in enumerate(quiz_data["mcqs"]):
                        user_answer_prefix = user_mcq_answers.get(i, "").split(')')[0]
                        if user_answer_prefix == mcq['correct_answer']:
                            st.success(f"**{i+1}. Correct!** Your answer: {user_mcq_answers[i]}")
                            score_mcq += 1
                        else:
                            st.error(f"**{i+1}. Incorrect.** Your answer: {user_mcq_answers.get(i, 'Not answered')}. Correct answer: {mcq['correct_answer']}) {mcq['options'][mcq['correct_answer']]}")
                    st.info(f"You scored {score_mcq} out of {len(quiz_data['mcqs'])} on MCQs.")
                    st.markdown("---")

            # --- True/False ---
            if quiz_data["true_false"]:
                st.markdown("#### True/False Questions")
                user_tf_answers = {}
                for i, tf in enumerate(quiz_data["true_false"]):
                    st.markdown(f"**{i+1}. {tf['question']}**")
                    user_tf_answers[i] = st.radio("Select your answer:", ["True", "False"], key=f"tf_{i}")
                
                if st.button("Check True/False Answers", key="check_tf"):
                    st.markdown("---")
                    st.markdown("#### True/False Results")
                    score_tf = 0
                    for i, tf in enumerate(quiz_data["true_false"]):
                        if user_tf_answers.get(i) == tf['correct_answer']:
                            st.success(f"**{i+1}. Correct!** Your answer: {user_tf_answers[i]}")
                            score_tf += 1
                        else:
                            st.error(f"**{i+1}. Incorrect.** Your answer: {user_tf_answers.get(i, 'Not answered')}. Correct answer: {tf['correct_answer']}")
                    st.info(f"You scored {score_tf} out of {len(quiz_data['true_false'])} on True/False questions.")
                    st.markdown("---")

            # --- Fill-in-the-Blank ---
            if quiz_data["fill_in_the_blank"]:
                st.markdown("#### Fill-in-the-Blank Questions")
                user_fib_answers = {}
                for i, fib in enumerate(quiz_data["fill_in_the_blank"]):
                    st.markdown(f"**{i+1}. {fib['question']}**")
                    user_fib_answers[i] = st.text_input("Your answer:", key=f"fib_{i}").strip()
                
                if st.button("Check Fill-in-the-Blank Answers", key="check_fib"):
                    st.markdown("---")
                    st.markdown("#### Fill-in-the-Blank Results")
                    score_fib = 0
                    for i, fib in enumerate(quiz_data["fill_in_the_blank"]):
                        if user_fib_answers.get(i, "").lower() == fib['correct_answer'].lower():
                            st.success(f"**{i+1}. Correct!** Your answer: {user_fib_answers[i]}")
                            score_fib += 1
                        else:
                            st.error(f"**{i+1}. Incorrect.** Your answer: {user_fib_answers.get(i, 'Not answered')}. Correct answer: {fib['correct_answer']}")
                    st.info(f"You scored {score_fib} out of {len(quiz_data['fill_in_the_blank'])} on Fill-in-the-Blank questions.")
                    st.markdown("---")


if __name__ == "__main__":
    main()
